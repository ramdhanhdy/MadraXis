#!/usr/bin/env node

/**
 * Metro Bundle Analyzer for React Native
 * 
 * Analyzes React Native bundles generated by Metro bundler
 * Provides insights into:
 * - Bundle composition
 * - Module sizes
 * - Import dependencies
 * - Optimization opportunities
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class MetroBundleAnalyzer {
  constructor() {
    this.outputDir = './performance-reports/metro';
    this.ensureOutputDir();
    this.timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  }

  ensureOutputDir() {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }
  }

  async analyzeBundle(platform = 'android') {
    console.log(`üîç Analyzing Metro bundle for ${platform}...`);

    try {
      // Generate bundle with source map
      const bundlePath = path.join(this.outputDir, `${platform}-bundle-${this.timestamp}.js`);
      const sourceMapPath = path.join(this.outputDir, `${platform}-bundle-${this.timestamp}.js.map`);

      console.log('  üì¶ Generating bundle...');
      await this.generateBundle(platform, bundlePath, sourceMapPath);

      console.log('  üìä Analyzing bundle composition...');
      const analysis = await this.analyzeBundleComposition(bundlePath, sourceMapPath);

      console.log('  üíæ Saving analysis report...');
      await this.saveAnalysis(platform, analysis);

      console.log(`‚úÖ ${platform} bundle analysis complete!`);
      return analysis;

    } catch (error) {
      console.error(`‚ùå ${platform} bundle analysis failed:`, error.message);
      throw error;
    }
  }

  async generateBundle(platform, bundlePath, sourceMapPath) {
    const command = `npx react-native bundle ` +
      `--platform ${platform} ` +
      `--dev false ` +
      `--entry-file index.js ` +
      `--bundle-output ${bundlePath} ` +
      `--sourcemap-output ${sourceMapPath} ` +
      `--assets-dest ${this.outputDir}/assets`;

    try {
      execSync(command, { stdio: 'pipe' });
    } catch (error) {
      // Try alternative approach using Expo CLI
      console.log('  üîÑ Trying alternative bundle generation...');
      const expoCommand = `npx expo export --platform ${platform} --clear`;
      execSync(expoCommand, { stdio: 'pipe' });
      
      // Copy generated bundle
      const expoBundlePath = `.expo-shared/${platform}-bundle`;
      if (fs.existsSync(expoBundlePath)) {
        execSync(`cp -r ${expoBundlePath}/* ${this.outputDir}/`, { stdio: 'pipe' });
      }
    }
  }

  async analyzeBundleComposition(bundlePath, sourceMapPath) {
    const analysis = {
      bundleSize: 0,
      modules: [],
      topModules: [],
      categories: {
        'node_modules': { size: 0, count: 0 },
        'src': { size: 0, count: 0 },
        'app': { size: 0, count: 0 },
        'other': { size: 0, count: 0 }
      },
      recommendations: []
    };

    // Get bundle size
    if (fs.existsSync(bundlePath)) {
      analysis.bundleSize = fs.statSync(bundlePath).size;
    }

    // Analyze source map if available
    if (fs.existsSync(sourceMapPath)) {
      try {
        const sourceMap = JSON.parse(fs.readFileSync(sourceMapPath, 'utf8'));
        analysis.modules = this.analyzeSourceMap(sourceMap);
        analysis.topModules = this.getTopModules(analysis.modules);
        analysis.categories = this.categorizeModules(analysis.modules);
      } catch (error) {
        console.warn('  ‚ö†Ô∏è  Source map analysis failed:', error.message);
      }
    }

    // Generate recommendations
    analysis.recommendations = this.generateRecommendations(analysis);

    return analysis;
  }

  analyzeSourceMap(sourceMap) {
    const modules = [];
    
    if (sourceMap.sources) {
      sourceMap.sources.forEach((source, index) => {
        // Estimate module size based on source map data
        // This is a simplified approach - real implementation would be more sophisticated
        const estimatedSize = source.length * 10; // Rough estimate
        
        modules.push({
          name: source,
          size: estimatedSize,
          index: index
        });
      });
    }

    return modules.sort((a, b) => b.size - a.size);
  }

  getTopModules(modules, count = 20) {
    return modules.slice(0, count);
  }

  categorizeModules(modules) {
    const categories = {
      'node_modules': { size: 0, count: 0, modules: [] },
      'src': { size: 0, count: 0, modules: [] },
      'app': { size: 0, count: 0, modules: [] },
      'other': { size: 0, count: 0, modules: [] }
    };

    modules.forEach(module => {
      let category = 'other';
      
      if (module.name.includes('node_modules')) {
        category = 'node_modules';
      } else if (module.name.includes('/src/')) {
        category = 'src';
      } else if (module.name.includes('/app/')) {
        category = 'app';
      }

      categories[category].size += module.size;
      categories[category].count += 1;
      categories[category].modules.push(module);
    });

    return categories;
  }

  generateRecommendations(analysis) {
    const recommendations = [];

    // Large bundle size
    if (analysis.bundleSize > 5 * 1024 * 1024) { // 5MB
      recommendations.push({
        type: 'bundle-size',
        severity: 'high',
        message: `Bundle size (${(analysis.bundleSize / 1024 / 1024).toFixed(2)}MB) is large`,
        actions: [
          'Enable Hermes engine for better performance',
          'Use ProGuard/R8 for Android builds',
          'Implement code splitting where possible'
        ]
      });
    }

    // Too many node_modules
    if (analysis.categories.node_modules.size > analysis.bundleSize * 0.7) {
      recommendations.push({
        type: 'dependencies',
        severity: 'medium',
        message: 'Dependencies account for >70% of bundle size',
        actions: [
          'Audit and remove unused dependencies',
          'Use lighter alternatives for heavy libraries',
          'Enable tree shaking in Metro config'
        ]
      });
    }

    // Large individual modules
    const largeModules = analysis.topModules.filter(m => m.size > 100000); // 100KB
    if (largeModules.length > 0) {
      recommendations.push({
        type: 'large-modules',
        severity: 'medium',
        message: `Found ${largeModules.length} modules larger than 100KB`,
        actions: [
          'Consider lazy loading for large modules',
          'Split large components into smaller ones',
          'Use dynamic imports where appropriate'
        ]
      });
    }

    return recommendations;
  }

  async saveAnalysis(platform, analysis) {
    const reportPath = path.join(this.outputDir, `${platform}-analysis-${this.timestamp}.json`);
    fs.writeFileSync(reportPath, JSON.stringify(analysis, null, 2));

    // Generate HTML report
    const htmlReport = this.generateHtmlReport(platform, analysis);
    const htmlPath = path.join(this.outputDir, `${platform}-report-${this.timestamp}.html`);
    fs.writeFileSync(htmlPath, htmlReport);

    console.log(`  üìÑ Analysis saved: ${reportPath}`);
    console.log(`  üåê HTML report: ${htmlPath}`);
  }

  generateHtmlReport(platform, analysis) {
    return `
<!DOCTYPE html>
<html>
<head>
    <title>Metro Bundle Analysis - ${platform}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 8px; }
        .metric { display: inline-block; margin: 10px; padding: 15px; background: #e3f2fd; border-radius: 4px; }
        .section { margin: 20px 0; }
        .module-list { max-height: 400px; overflow-y: auto; }
        .module { padding: 8px; border-bottom: 1px solid #eee; }
        .recommendation { background: #fff3e0; padding: 15px; margin: 10px 0; border-left: 4px solid #ff9800; }
        .high { border-left-color: #f44336; }
        .medium { border-left-color: #ff9800; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Metro Bundle Analysis - ${platform.toUpperCase()}</h1>
        <p>Generated: ${this.timestamp}</p>
    </div>

    <div class="section">
        <h2>Bundle Metrics</h2>
        <div class="metric">
            <strong>Bundle Size:</strong><br>
            ${(analysis.bundleSize / 1024 / 1024).toFixed(2)} MB
        </div>
        <div class="metric">
            <strong>Total Modules:</strong><br>
            ${analysis.modules.length}
        </div>
        <div class="metric">
            <strong>Dependencies:</strong><br>
            ${analysis.categories.node_modules.count} modules
        </div>
    </div>

    <div class="section">
        <h2>Top Modules by Size</h2>
        <div class="module-list">
            ${analysis.topModules.map(module => `
            <div class="module">
                <strong>${path.basename(module.name)}</strong><br>
                <small>${module.name}</small><br>
                Size: ${(module.size / 1024).toFixed(2)} KB
            </div>
            `).join('')}
        </div>
    </div>

    <div class="section">
        <h2>Recommendations</h2>
        ${analysis.recommendations.map(rec => `
        <div class="recommendation ${rec.severity}">
            <strong>${rec.type.toUpperCase()}:</strong> ${rec.message}
            <ul>
                ${rec.actions.map(action => `<li>${action}</li>`).join('')}
            </ul>
        </div>
        `).join('')}
    </div>
</body>
</html>
    `;
  }
}

// CLI interface
if (require.main === module) {
  const platform = process.argv[2] || 'android';
  const analyzer = new MetroBundleAnalyzer();
  analyzer.analyzeBundle(platform).catch(console.error);
}

module.exports = MetroBundleAnalyzer;
